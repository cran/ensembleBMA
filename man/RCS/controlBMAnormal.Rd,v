head	1.5;
access;
symbols;
locks; strict;
comment	@# @;


1.5
date	2007.02.18.22.39.00;	author fraley;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.07.19.17.20;	author fraley;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.07.18.54.28;	author fraley;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.07.18.52.23;	author fraley;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.04.16.27.26;	author fraley;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@\name{controlBMAnormal}
\alias{controlBMAnormal}
\title{
  Control parameters for BMA for precipitation.
}
\description{
   Specifies a list of values controling the Bayesian Model Averaging fit 
   of a mixture of normals to ensemble forecasts.
}
\usage{
controlBMAnormal(maxIter, eps, equalVariance, biasCorrection, start) 
}
\arguments{
  \item{maxIter}{
     An integer specifying an upper limit on the number of iterations
     for fitting the BMA mixture via EM. The default is 
    \code{.Machine$integer.max}, which essentially sets no upper
     limit on the number of iterations, so that the convergence
     criterion based on \code{eps} is used.
  }
  \item{eps}{
     A numeric convergence tolerance. The EM fit for the mixture 
     model is terminated when the relative error in successive 
     objective values in the M-step falls below \code{eps}.
     The default is \code{sqrt(.Machine$double.eps)}, 
     which is approximately \code{1.e-8} on IEEE compliant machines.
  }
  \item{equalVariance}{
     A logical value indicating whether or not the variances for
     the mixture components should to be equal.
     The default is to constrain them to be equal.
  }
  \item{biasCorrection}{
   A character string describing the type of bias correction to be used.
  \describe{
   \item{\code{"regression"}}{
    The bias correction term is formed by regression on the forecast values 
    (including an intercept).
   }
   \item{\code{"additive"}}{
      The mean of the difference between observations 
      and forecasts is used for bias correction.
   }
   \item{\code{"none"}}{
      No bias correction.
   }
  }
  }
 \item{start}{
     An optional list of starting values for standard deviations 
     and weights. The default is to start with all standard deviations
     equal to 1, and with equal weights for each member of the ensemble.
  }
}
\value{
  A list whose components are the input arguments and their assigned values. 
}
\seealso{
  \code{\link{ensembleBMAnormal}}, 
  \code{\link{forecastBMAnormal}}, 
  \code{\link{fitBMAnormal}}
}
\references{
A. E. Raftery, T. Gneiting, F. Balabdaoui and M. Polakowski,
Using Bayesian Model Averaging to Calibrate Forecast Ensembles,
\emph{Monthly Weather Review 133:1155-1174, 2005}.
}

\examples{
  data(slp)

  slpData <- ensembleData(forecasts = slp[c("AVN","GEM","ETA","NGM","NOGAPS")],
                          observations = slp$obs, dates = slp$date,
                          latitude = slp$lat, longitude = slp$lon)

  slpFit <- ensembleBMAnormal(slpData, 
    control = controlBMAnormal(maxIter = 100, 
                               equalVariance = FALSE,
                               biasCorrection = "additive"))
}
\keyword{models}
% docclass is function
@


1.4
log
@*** empty log message ***
@
text
@d72 2
a73 2
  slpData <- ensembleData(forecasts = slp[c("AVN", "GEM", "ETA", "NGM", "NOGAPS")],
                          observations = slp$obs, dates = slp$init_date,
@


1.3
log
@*** empty log message ***
@
text
@d72 1
a72 1
  slpData <- ensembleData(forecasts = slp[forecasts = c("AVN", "GEM", "ETA", "NGM", "NOGAPS")],
@


1.2
log
@*** empty log message ***
@
text
@d73 2
a74 2
                                          obs = slp$obs, dates = slp$init_date,
                                          latitude = slp$lat, longitude = slp$lon)
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
controlBMAnormal(maxIter, eps, equalVariance, biasCorrection) 
d19 1
a19 1
     criterion based on \code{eps} to be enforced.
d49 5
d72 3
a74 2
  slpData <- ensembleData(forecasts = slp[,4:8], observations = slp[,9],
               dates = slp[,1], latitude = slp[,2], longitude = slp[,3])
@
